#!/usr/bin/env perl

use 5.010;
use utf8;
use strict;
use warnings;
use autodie;
use Pod::Usage;
use Getopt::Long qw(:config auto_version auto_help);
use URI;
use URI::Escape;
use Gerrit::REST;

our $VERSION = '0.000';

# The %Options hash is used to hold the command line options passed to
# all git-gerrit subcommands. The --verbose option is common to all of
# them. Each subcommand supports a specific set of options which are
# grokked by the get_options routine below.

my %Options = ( debug => 0 );
sub get_options {
    my (@opt_specs) = @_;
    return GetOptions(\%Options, 'debug', @opt_specs)
        or pod2usage(2);
}

# The cmd routine is used to invoke shell commands, usually git. It
# prints out the command before invoking it in debug operation.

sub cmd {
    my ($cmd) = @_;
    warn "CMD: $cmd\n" if $Options{debug};
    return system($cmd) == 0;
}

# The %Config hash holds the git-gerrit section configuration options.

my %Config;
sub grok_config {
    warn "CMD: git config --get-regexp \"^git-gerrit\\.\"\n"
        if $Options{debug};
    {
        open my $pipe, '-|', 'git config --get-regexp "^git-gerrit\."';
        while (<$pipe>) {
            if (/^git-gerrit\.(\S+)\s+(.*)/) {
                push @{$Config{$1}}, $2;
            } else {
                warn "Strange git-config output: $_";
            }
        }
    }

    # Override option defaults
    for my $opt (qw/verbose/) {
        $Options{$opt} = $Config{"default-$opt"}[-1]
            if exists $Config{"default-$opt"};
    }

    unless ($Config{baseurl} && $Config{project} && $Config{remote}) {
        warn <<EOF;

*** Please configure git-gerrit:

EOF

        warn <<EOF unless $Config{baseurl};
Run

    git config --global git-gerrit.baseurl "https://your.gerrit.domain"

to set your Gerrit server base URL. Omit --global if you only want to
configure it for this particular repository.

EOF

        warn <<EOF unless $Config{project};
Run

    git config git-gerrit.project "gerrit/project/name"

to set the Gerrit project your repository is associated with.

EOF

        warn <<EOF unless $Config{remote};
Run

    git config git-gerrit.remote "remote"

to set the git remote pointing to the Gerrit project.

EOF

        die;
    }

    $Config{baseurl}[-1] =~ s:/+$::; # trim trailing slashes from the baseurl

    push @{$Config{url}}, URI->new($Config{baseurl}[-1] . '/' . $Config{project}[-1]);

    $Config{baseurl}[-1] = URI->new($Config{baseurl}[-1]);

    chomp(my $gitdir = qx/git rev-parse --git-dir/);
    push @{$Config{gitdir}}, $gitdir;

    return;
}

sub config {
    my ($var) = @_;
    if (wantarray) {
        return exists $Config{$var} ? @{$Config{$var}}  : ();
    } else {
        return exists $Config{$var} ? $Config{$var}[-1] : undef;
    }
}

# The install_commit_msg_hook routine is invoked by a few of
# git-gerrit subcommands. It checks if the current repository already
# has a commit-msg hook installed. If not, it tries to download and
# install Gerrit's default commit-msg hook, which inserts Change-Ids
# in commits messages.

sub install_commit_msg_hook {
    require File::Spec;

    # Do nothing if it already exists
    my $commit_msg = File::Spec->catfile(scalar(config('gitdir')), 'hooks', 'commit-msg');
    return if -e $commit_msg;

    # Otherwise, check if we need to mkdir the hooks directory
    my $hooks_dir = File::Spec->catdir(scalar(config('gitdir')), 'hooks');
    mkdir $hooks_dir unless -e $hooks_dir;

    # Try to download and install the hook.
    eval { require LWP::Simple };
    if ($@) {
        warn "LWP: cannot install commit_msg hook because couldn't require LWP::Simple\n"
            if $Options{debug};
    } else {
        warn "LWP: install commit_msg hook\n" if $Options{debug};
        if (LWP::Simple::is_success(LWP::Simple::getstore(config('baseurl') . "/tools/hooks/commit-msg", $commit_msg))) {
            chmod 0755, $commit_msg;
        }
    }
}

# The credential_* routines below use the git-credential command to
# get and set credentials for git commands and also for Gerrit REST
# interactions.

sub credential_description {
    my $baseurl = config('baseurl');

    my $protocol = $baseurl->scheme;
    my $host     = $baseurl->host;
    my $path     = $baseurl->path;

    my $description = <<EOF;
protocol=$protocol
host=$host
path=$path
EOF

    if (my $username = config('username')) {
        $description .= <<EOF
username=$username
EOF
    }

    return $description;
}

sub get_credentials {
    # Create a temporary file to hold the credential description
    require File::Temp;
    my ($fh, $credfile) = File::Temp::tempfile(UNLINK => 1);
    $fh->print(credential_description(), "\n");
    $fh->print("\n");
    $fh->close;

    my %credentials;
    open my $pipe, '-|', "git credential fill <$credfile";
    while (<$pipe>) {
        chomp;
        $credentials{$1} = $2 if /^([^=]+)=(.*)/;
    }
    close $pipe;

    for my $key (qw/username password/) {
        exists $credentials{$key} or die "Couldn't get credential's $key\n";
    }

    return @credentials{qw/username password/};
}

sub set_credentials {
    my ($username, $password, $what) = @_;

    $what =~ /^(?:approve|reject)$/
        or die "set_credentials \$what argument ($what) must be either 'approve' or 'reject'\n";

    open my $git, '|-', "git credential $what";
    $git->print(credential_description(), "password=$password\n\n");
    $git->close;

    return;
}

# The get_message routine returns the message argument to the
# --message option. If the option is not present it invokes the git
# editor to let the user compose a message and returns it.

sub get_message {
    return $Options{message} if exists $Options{message};

    chomp(my $editor = qx/git var GIT_EDITOR/);

    die "Please, see 'git help var' to see how to set up an editor for git messages.\n"
        unless $editor;

    require File::Temp;
    my $tmp = File::Temp->new();

    require File::Slurp;
    File::Slurp::write_file($tmp->filename, <<'EOF');

# Please enter the review message for this change. Lines starting
# with '#' will be ignored, and an empty message aborts the review.
EOF

    cmd "$editor $tmp"
        or die "Aborting because I couldn't invoke '$editor $tmp'.\n";

    my $message = File::Slurp::read_file($tmp->filename);

    $message =~ s/(?<=\n)#.*?\n//gs; # remove all lines starting with '#'

    return $message;
}

# The gerrit routine keeps a cached Gerrit::REST object to which it
# relays REST calls.

sub gerrit {
    my $method = shift;

    state $gerrit;
    unless ($gerrit) {
        my ($username, $password) = get_credentials;
        $gerrit = Gerrit::REST->new(config('baseurl')->as_string, $username, $password);
        eval { $gerrit->GET("/projects/" . uri_escape_utf8(config('project'))) };
        if ($@) {
            set_credentials($username, $password, 'reject');
            die $@;
        } else {
            set_credentials($username, $password, 'approve');
        }
    }

    if ($Options{debug}) {
        my ($endpoint, @args) = @_;
        warn "GERRIT: $method $endpoint\n";
        if (@args) {
            require Data::Dumper;
            warn Data::Dumper::Dumper(@args);
        }
    }

    return $gerrit->$method(@_);
}

# The query_changes routine receives a list of strings to query the
# Gerrit server. It returns an array-ref containing a list of
# array-refs, each containing a list of change descriptions.

sub query_changes {
    my @queries = @_;

    return [] unless @queries;

    # If we're inside a git repository, restrict the query to the
    # current project's reviews.
    if (my $project = config('project')) {
        $project = uri_escape_utf8($project);
        @queries = map "q=project:$project+$_", @queries;
    }

    push @queries, "n=$Options{limit}" if $Options{limit};

    push @queries, "o=DETAILED_ACCOUNTS";

    my $changes = gerrit(GET => "/changes/?" . join('&', @queries));
    $changes = [$changes] if ref $changes->[0] eq 'HASH';

    return $changes;
}

# The get_change routine returns the description of a change
# identified by $id. An optional boolean second argument ($allrevs)
# tells if the change description should contain a description of all
# patchsets or just the current one.

sub get_change {
    my ($id, $allrevs) = @_;

    my $revs = $allrevs ? 'ALL_REVISIONS' : 'CURRENT_REVISION';
    return (gerrit(GET => "/changes/?q=change:$id&o=$revs"))[0][0];
}

# The current_branch routine returns the name of the current branch or
# 'HEAD' in a dettached head state.

sub current_branch {
    chomp(my $branch = qx/git rev-parse --abbrev-ref HEAD/);
    return $branch;
}

# The update_branch routine receives a local $branch name and updates
# it with the homonym branch in the Gerrit remote.

sub update_branch {
    my ($branch) = @_;

    my $remote = config('remote');
    cmd "git fetch $remote $branch:$branch";
}

# The following change_branch_* routines are used to create, list, and
# grok the local change-branches, i.e., the ones we create locally to
# map Gerrit's changes. Their names have a fixed format like this:
# "change/<upstream>/<id>. <Upstream> is the name of the local branch
# from which this change was derived. <Id> can be either a number,
# meaning the numeric id of a change already in Gerrit, or a
# topic-name, which was created by the "git-gerrit new <topic>"
# command.

sub change_branch_new {
    my ($upstream, $topic) = @_;
    die "The TOPIC cannot contain the slash character (/).\n"
        if $topic =~ m:/:;
    return "change/$upstream/$topic";
}

sub change_branch_lists {
    chomp(my @branches = map s/^\*?\s+//, qx/git branch --list 'change*'/);
    return @branches;
}

sub change_branch_info {
    my ($branch) = @_;
    if ($branch =~ m:^change/(?<upstream>.*)/(?<id>[^/]+):) {
        return ($+{upstream}, $+{id});
    }
    return;
}

# The current_change routine returns a list of two items: the upstream
# and the id of the change branch we're currently in. If we're not in
# a change branch, it returns the empty list.

sub current_change {
    return change_branch_info(current_branch);
}

# The current_change_id routine returns the id of the change branch
# we're currently in. If we're not in a change branch, it returns
# undef.

sub current_change_id {
    my ($branch, $id) = current_change;

    return $id;
}

############################################################
# MAIN

# Each git-gerrit subcommand is implemented by an anonymous routine
# associated with one or more names in the %commands hash.

my %commands;

$commands{new} = sub {
    get_options('update');

    my $topic = shift @ARGV
        or pod2usage "new: Missing TOPIC.\n";

    $topic !~ m:/:
        or die "new: the topic name ($topic) should not contain slashes.\n";

    $topic =~ m:\D:
        or die "new: the topic name ($topic) should contain at lease one non-digit character.\n";

    my $branch = shift @ARGV || current_branch;

    if (my ($upstream, $id) = change_branch_info($branch)) {
        die "new: You can't base a new change on a change branch ($branch).\n";
    }

    my $status = qx/git status --porcelain --untracked-files=no/;

    warn "Warning: git-status tells me that your working area is dirty:\n$status\n"
        if $status ne '';

    if ($Options{update}) {
        update_branch($branch)
            or die "new: Non-fast-forward pull. Please, merge or rebase your branch first.\n";
    }

    cmd "git checkout -b change/$branch/$topic $branch";

    install_commit_msg_hook;
};

$commands{query} = sub {
    get_options(
        'verbose',
        'limit=i',
    );

    my (@names, @queries);
    foreach my $arg (@ARGV) {
        if ($arg =~ /(?<name>.*?)=(?<query>.*)/) {
            push @names,   $+{name};
            push @queries, $+{query};
        } else {
            push @names,   "QUERY";
            push @queries, $arg;
        }
    }

    my $changes = query_changes(@queries);

    # FIXME: consider using Text::Table for formatting
    my $format = "%-5s %-9s %-19s %-20s %-12s %-24s %s\n";
    for (my $i=0; $i < @$changes; ++$i) {
        print "\n[$names[$i]=$queries[$i]]\n";
        next unless @{$changes->[$i]};
        printf $format, 'ID', 'STATUS', 'UPDATED', 'PROJECT', 'BRANCH', 'OWNER', 'SUBJECT';
        foreach my $change (sort {$b->{updated} cmp $a->{updated}} @{$changes->[$i]}) {
            if ($Options{verbose}) {
                if (my $topic = gerrit(GET => "/changes/$change->{id}/topic")) {
                    $change->{branch} .= " ($topic)";
                }
            }
            printf $format,
                $change->{_number},
                $change->{status},
                substr($change->{updated}, 0, 19),
                $change->{project},
                $change->{branch},
                substr($change->{owner}{name}, 0, 24),
                $change->{subject};
        }
    }
    print "\n";
};

my %StandardQueries = (
    changes => [
        'Outgoing reviews=is:open+owner:self',
        'Incoming reviews=is:open+reviewer:self+-owner:self',
        'Recently closed=is:closed+owner:self+-age:1mon',
    ],
    drafts  => ['Drafts=is:draft'],
    watched => ['Watched changes=is:watched+status:open'],
    starred => ['Starred changes=is:starred'],
);
$commands{my} = sub {
    if (@ARGV) {
        if (exists $StandardQueries{$ARGV[-1]}) {
            splice @ARGV, -1, 1, @{$StandardQueries{$ARGV[-1]}};
        } elsif ($ARGV[-1] =~ /^-/) {
            # By default we show 'My Changes'
            push @ARGV, @{$StandardQueries{changes}};
        } else {
            pod2usage "my: Invalid change specification: '$ARGV[-1]'";
        }
    } else {
        # By default we show 'My Changes'
        push @ARGV, @{$StandardQueries{changes}};
    }

    $commands{query}();
};

$commands{show} = sub {
    get_options('verbose');

    my $id = shift @ARGV || current_change_id()
        or pod2usage "show: Missing CHANGE.\n";

    my $change = gerrit(GET => "/changes/$id/detail");

    print <<EOF;
 Change-Num: $change->{_number}
  Change-Id: $change->{change_id}
    Subject: $change->{subject}
      Owner: $change->{owner}{name}
EOF

    if ($Options{verbose}) {
        if (my $topic = gerrit(GET => "/changes/$id/topic")) {
            $change->{topic} = $topic;
        }
    }

    for my $key (qw/project branch topic created updated status reviewed mergeable/) {
        printf "%12s %s\n", "\u$key:", $change->{$key}
            if exists $change->{$key};
    }

    for my $label (sort keys %{$change->{permited_labels}}) {
        for my $review (sort {$a->{name} cmp $b->{name}} @{$change->{labels}{$label}{all}}) {
            printf "%12s %-32s %+2d\n", "$label:", @{$review}{qw/name value/};
        }
    }
};

$commands{config} = sub {
    cmd "git config --get-regexp \"^git-gerrit\\.\"";
};

$commands{checkout} = sub {
    get_options();

    my $id = shift @ARGV || current_change_id()
        or pod2usage "checkout: Missing CHANGE.\n";

    my $change = get_change($id);

    my ($revision) = values %{$change->{revisions}};

    my ($url, $ref) = @{$revision->{fetch}{http}}{qw/url ref/};

    my $branch = "change/$change->{branch}/$change->{_number}";

    cmd "git fetch $url $ref:$branch"
        or die "Can't fetch $url\n";

    cmd "git checkout $branch";
};

$commands{backout} = sub {
    get_options('keep');

    my $branch = current_branch;

    if (my ($upstream, $id) = change_branch_info($branch)) {
        if (cmd "git checkout $upstream") {
            if ($id =~ /^\d+$/ && ! $Options{keep}) {
                cmd "git branch -D $branch";
            } else {
                warn "Keeping $branch\n";
            }
        }
    } else {
        die "backout: You aren't in a change branch. I cannot back you out.\n";
    }
};

$commands{push} = sub {
    get_options(
        'keep',
        'force',
        'rebase',
        'draft',
        'topic=s',
        'reviewer=s@',
        'cc=s@'
    );

    qx/git status --porcelain --untracked-files=no/ eq ''
        or die "push: Can't push change because git-status is dirty\n";

    my $branch = current_branch;

    my ($upstream, $id) = change_branch_info($branch)
        or die "push: You aren't in a change branch. I cannot push it.\n";

    my @commits = qx/git log --decorate=no --oneline HEAD ^$upstream/;
    if (@commits == 0) {
        die "push: no changes between $upstream and $branch. Pushing would be pointless.\n";
    } elsif (@commits > 1 && ! $Options{force}) {
        die <<EOF;
push: you have more than one commit that you are about to push.
      The outstanding commits are:

 @commits
      If this is really what you want to do, please try again with --force.
EOF
    }

    if ($Options{rebase} || $id =~ /\D/) {
        update_branch($upstream)
            or die "push: Non-fast-forward pull. Please, merge or rebase your branch first.\n";
        cmd "git rebase $upstream";
    }

    my $refspec = 'HEAD:refs/' . ($Options{draft} ? 'draft' : 'for') . "/$upstream";

    my @tags;
    if (my $topic = $Options{topic}) {
        push @tags, "topic=$topic";
    } elsif ($id =~ /\D/) {
        push @tags, "topic=$id";
    }
    if (my $reviewers = $Options{reviewer}) {
        push @tags, map("r=$_", split(/,/, join(',', @$reviewers)));
    }
    if (my $ccs = $Options{cc}) {
        push @tags, map("cc=$_", split(/,/, join(',', @$ccs)));
    }
    if (@tags) {
        $refspec .= '%';
        $refspec .= join(',', @tags);
    }

    my $remote = config('remote');
    cmd "git push $remote $refspec"
        or die "push: Error pushing change.\n";

    unless ($Options{keep}) {
        cmd("git checkout $upstream") and cmd("git branch -D $branch");
    }

    install_commit_msg_hook;
};

$commands{reviewer} = sub {
    get_options(
        'add=s@',
        'confirm',
        'delete=s@',
    );

    my $id = shift @ARGV || current_change_id()
        or pod2usage "reviewer: Missing CHANGE.\n";

    # First try to make all deletions
    if (my $users = $Options{delete}) {
        foreach my $user (split(/,/, join(',', @$users))) {
            gerrit(DELETE => "/changes/$id/reviewers/$user");
        }
    }

    # Second try to make all additions
    if (my $users = $Options{add}) {
        my $confirm = $Options{confirm} ? 'true' : 'false';
        foreach my $user (split(/,/, join(',', @$users))) {
            gerrit(POST => "/changes/$id/reviewers/$user", { reviewer => $user, confirm => $confirm});
        }
    }

    # Finally, list current reviewers
    my @reviewers = gerrit(GET => "/changes/$id/reviewers");
    print "There are ", scalar(@reviewers), " reviewers currently:\n";
    foreach my $reviewer (@reviewers) {
        print "$reviewer->{name}\t$reviewer->{email}\t";
        foreach my $approval (sort keys $reviewer->{approvals}) {
            print "$approval:$reviewer->{approvals}{$approval}";
        } continue {
            print ", ";
        }
        print "\n";
    }
};

$commands{review} = sub {
    get_options(
        'message=s',
        'keep',
    );

    my %review;

    if (my $message = get_message) {
        $review{message} = $message;
    }

    # Set all votes
    while (@ARGV && $ARGV[0] =~ /(?<label>.*)=(?<vote>.*)/) {
        shift @ARGV;
        $review{labels}{$+{label} || 'Code-Review'} = $+{vote};
        $+{vote} =~ /^[+-]?\d$/
            or pod2usage "review: Invalid vote ($+{vote}). It must be a single digit optionally prefixed by a [-+] sign.\n";
    }

    die "review: Invalid vote $ARGV[0].\n" if @ARGV > 1;

    die "review: You must specify a message or a vote to review.\n"
        unless keys %review;

    if (my $id = shift @ARGV) {
        gerrit(POST => "/changes/$id/revisions/current/review", \%review);
    } else {
        my $branch = current_branch;

        my ($upstream, $id) = change_branch_info($branch)
            or die "review: Missing CHANGE.\n";

        gerrit(POST => "/changes/$id/revisions/current/review", \%review);

        unless ($Options{keep}) {
            cmd("git checkout $upstream") and cmd("git branch -D $branch");
        }
    }
};

$commands{abandon} = sub {
    get_options(
        'message=s',
        'keep',
    );

    my @args;

    if (my $message = get_message) {
        push @args, { message => $message };
    }

    if (my $id = shift @ARGV) {
        gerrit(POST => "/changes/$id/abandon", @args);
    } else {
        my $branch = current_branch;

        my ($upstream, $id) = change_branch_info($branch)
            or die "abandon: Missing CHANGE.\n";

        gerrit(POST => "/changes/$id/abandon", @args);

        unless ($Options{keep}) {
            cmd("git checkout $upstream") and cmd("git branch -D $branch");
        }
    }
};

$commands{restore} = sub {
    get_options('message=s');

    my $id = shift @ARGV || current_change_id()
        or pod2usage "restore: Missing CHANGE.\n";

    my @args = ("/changes/$id/restore");

    if (my $message = get_message) {
        push @args, { message => $message };
    }

    gerrit(POST => @args);
};

$commands{revert} = sub {
    get_options('message=s');

    my $id = shift @ARGV || current_change_id()
        or pod2usage "revert: Missing CHANGE.\n";

    my @args = ("/changes/$id/revert");

    if (my $message = get_message) {
        push @args, { message => $message };
    }

    gerrit(POST => @args);
};

$commands{submit} = sub {
    get_options(
        'no-wait-for-merge',
        'keep',
    );

    my @args;
    push @args, { wait_for_merge => 1 } unless $Options{'no-wait-for-merge'};

    if (my $id = shift @ARGV) {
        gerrit(POST => "/changes/$id/submit", @args);
    } else {
        my $branch = current_branch;

        my ($upstream, $id) = change_branch_info($branch)
            or die "submit: Missing CHANGE.\n";

        gerrit(POST => "/changes/$id/submit", @args);

        unless ($Options{keep}) {
            cmd("git checkout $upstream") and cmd("git branch -D $branch");
        }
    }
};

$commands{version} = sub {
    print "git-gerrit version $VERSION\n";
    cmd "git version";
    my $version = eval { gerrit(GET => '/config/server/version') };
    $version //= "pre-2.7, since it doesn't support the Get Version REST Endpoint";
    print "Gerrit version $version\n";
};

# MAIN

my $command = shift
    or die pod2usage "Missing command name.\n";

exists $commands{$command}
    or die pod2usage "Invalid command: $command.\n";

grok_config;

$commands{$command}->();

__END__

=head1 NAME

git-gerrit - Git extension to implement a Gerrit workflow

=head1 SYNOPSIS

    git gerrit new      [--update] TOPIC [BRANCH]
    git gerrit push     [--keep] [--force] [--update] [--rebase] [--draft] [--reviewer USER] [--cc USER]

    git gerrit query    [--limit LIMIT] [--verbose] [[NAME=]QUERY]*
    git gerrit my       [--limit LIMIT] [--verbose] [changes|drafts|watched|starred]
    git gerrit show     [--verbose] [CHANGE]

    git gerrit checkout [CHANGE]
    git gerrit backout  [--keep]

    git gerrit reviewer [--add USERS] [--confirm] [--delete USERS] [CHANGE]
    git gerrit review   [--message TEXT] [--keep] [[LABEL]=VOTE]* [CHANGE]
    git gerrit abandon  [--message TEXT] [--keep] [CHANGE]
    git gerrit restore  [--message TEXT] [CHANGE]
    git gerrit revert   [--message TEXT] [CHANGE]
    git gerrit submit   [--no-wait-for-merge] [--keep] [CHANGE]

    git gerrit config
    git gerrit version

=head1 DESCRIPTION

Git-gerrit is a Git extension to manage changes using <Gerrit Code
Review|http://code.google.com/p/gerrit/>.

Git-gerrit offers a rich set of sub-commands to make it easy to
create, query, amend, review, and submit changes to Gerrit, making it
possible to interact with it through the command-line, avoiding its
web interface most of the time and improving your efficiency. The goal
is to make Gerrit's review process feel like a natural extension of
Git.

Git-gerrit provides three main features:

=over

=item * An easy and safe way to push changes to Gerrit through the
B<git gerrit push> sub-command, avoiding the need to type remote names
and long refspecs.

=item * A standard way to map Gerrit changes into local branches,
referred to as "change-branches", making it easier to manage several
changes simultaneously and to perform the fetch-amend-push review
cycle.

=item * Several sub-commands to query and inspect Gerrit changes and
also to review and submit them.

=back

Git-gerrit is implemented on top of L<Gerrit's REST
API|https://gerrit-review.googlesource.com/Documentation/rest-api.html>,
which was consolidated in its version 2.6. As this API matures, expect
git-gerrit to incorporate new functionality.

There are a few alternatives to git-gerrit described L<below|"SEE ALSO">.

=head1 INSTALLATION

Nothing fancy yet. Just copy git-gerrit to some directory on your PATH
so that Git can find it.

It needs at least Perl 5.10 and the following non-core modules:
C<Gerrit::REST>, C<File::Slurp>, and C<LWP::Simple>.

To read this documentation you simply call C<perldoc git-gerrit>.

=head1 CONFIGURATION

You must tell git-gerrit how to interact with your Gerrit server by
defining a few configuration variables in Git's C<git-gerrit>
configuration section.

The variables C<baseurl>, C<project>, and C<remote> are required. If
they aren't set, git-gerrit will provide a helpfull message telling
you how to set them up.

=over

=item * B<git-gerrit.baseurl>

The base URL of your Gerrit server. This usually can be configured
globally, if you have a Gerrit server hosting several of your
repositories.

=item * B<git-gerrit.project>

The project name associated with your repository.

=item * B<git-gerrit.remote>

The Git remote name you use to push commits to and fetch commits from
your Gerrit server.

=item * B<git-gerrit.username>

The username you use to authenticate with Gerrit. If not specified, it
will'll be asked for interactively.

=back

=head1 CHANGES, CHANGE-IDs, and CHANGE-BRANCHES

Let's try to make a few concepts clear so that the sub-commands
documentation below makes more sense.

=over

=item B<change>

Each commit pushed to one of Gerrit's virtual branches (C<refs/for> or
C<refs/draft>) creates a C<change> for review.

=item B<Change-Id>

A
L<Change-Id|https://gerrit-review.googlesource.com/Documentation/user-changeid.html>
is a 40-hexadecimal characters long SHA-1 hash prefixed with an
C<I>. It uniquely identifies a change and is normally generated by the
C<commit-msg> hook and inserted in the commit message footer.

=item B<{change-id}>

A
L<{change-id}|https://gerrit-review.googlesource.com/Documentation/rest-api-changes.html#change-id>,
is a more general identifier used by Gerrit's REST API to uniquely
identify a change . It can be expressed in one of three forms:

=over

=item * As an ID of the change in the format
"<project>~<branch>~<Change-Id>", where, for the branch, the
C<refs/heads/> prefix can be omitted (e.g.,
C<myProject~master~I8473b95934b5732ac55d26311a706c9c2bde9940>).

=item * As a C<Change-Id> if it uniquely identifies one change
(e.g., C<I8473b95934b5732ac55d26311a706c9c2bde9940>).

=item * As a legacy numeric change ID (e.g., C<4247>).

=back

You may pass any form of change-id to git-gerrit's sub-commands when
they require a CHANGE argument. Most commonly, you'll be using the
legacy numeric ID, just because it's shorter.

=item B<upstream branch>

You normally should avoid creating changes directly on a local
tracking branch. Instead, you should create a local topic branch
deriving from the tracking branch to work on each change. We refer to
the tracking branch from which your topic branch derived as the
topic's C<upstream branch>.

=item B<change-branch>

A C<change-branch> is a local branch with a special name that
git-gerrit creates and maps to a Gerrit change.

When the sub-command C<git gerrit new TOPIC BRANCH> starts a new
change it creates a topic branch named B<change/BRANCH/TOPIC>, which
we call a change-branch. We refer to BRANCH as the change-branch's
C<upstream>, because it is the branch from which the change-branch
derives and to which it will be ultimatelly merged back again.

When C<git gerrit checkout CHANGE> fetches an existing change it
creates a change-branch named B<change/BRANCH/ID>, where BRANCH is the
name of the branch associated with the change, and ID is its legacy
numeric change ID.

So, you should reserve the C<change/> top-level branch name for the
change-branches managed by git-gerrit.

=back

=head1 SUB-COMMANDS

Each git-gerrit sub-command has its own set of options. But there are
a global option accepted by all of them:

=over

=item --debug

This option makes git-gerrit print to STDERR every system command
(usually a Git command) invoked and every Gerrit REST call made during
the execution of its sub-commands. System commands are prefixed with
B<CMD:> and Gerrit REST calls with B<GERRIT:>.

=back

=head2 git gerrit new [--update] TOPIC [BRANCH]

The C<new> sub-command starts a new change on top of the current
branch or BRANCH, if specified. It creates a new change-branch off of
BRANCH called C<change/BRANCH/TOPIC> and checks it out for you to
start making changes to your working area.

The TOPIC name must contain at least one non-digit character so that
it's clear that this is a new change-branch, not yet pushed to
Gerrit. Also, the TOPIC name cannot contain slashes so that it's not
confused with the branch name. It's usually best to use only letters
and hyphens.

=over

=item B<--update>

This option makes git-gerrit update BRANCH before creating the
change-branch by fetching from Gerrit and fast-forward-merging it with
its remote branch. This way you guarantee to start a change on top of
the newest state of your project, which is usually the right thing to do.

=back

You will be warned if your working area is dirty, as this is sometimes
a mistake.

=head2 git gerrit push [--keep] [--force] [--rebase] [--draft] [--reviewer USERS] [--cc USERS]

The C<push> sub-command should be invoked to push a change-branch to
Gerrit's C<refs/for/> branch associated with its upstream branch. It
should be invoked when you have the change-branch checked out in your
working area.

When a new change-branch is pushed it creates a Gerrit change
associated with the TOPIC in its name, as created by C<git gerrit new>
above.

After a succesful push, git-gerrit checks out the upstream branch and
deletes the original change-branch. The goal is to maintain a clean
namespace, containing only the change-branches that are being worked
on. When you push one to Gerrit, you don't need to keep it any longer
locally. If you need to amend it later, you'll be able to get to it
with the C<git gerrit checkout> sub-command.

=over

=item B<--keep>

This option tells git-gerrit not to checkout the upstream and not to
delete the change-branch, keeping your working area intact.

=item B<--force>

By default, git-gerrit refuses to push a change-branch if it contains
more than one commit dangling from its upstream. It's best to avoid
multiple commit pushes, because if you have to amend them later,
having multiple commits may require rebasing dependent commits, which
is a more complex operation and clutters the review history of the
change.

This option makes git-gerrit perform multiple commit pushes without
complaining.

=item B<--rebase>

Before a brand new change-branch (one ending in a TOPIC C<name>) is
pushed, its upstream branch is updated and it is rebased on top of its
upstream. This is to make sure you're pushing a change based on the
newest project state.

A change-branch that has been checked out (one ending in an ID) isn't
rebased by default, because this would clutter the change review
history in Gerrit.

This option tells git-gerrit to always update the upstream and rebase
the change-branch before the push.

=item B<--draft>

This option makes git-gerrit push the change-branch to
C<refs/drafts/UPSTREAM> instead of to C<refs/for/UPSTREAM>, creating a
draft change in Gerrit.

=item B<--reviewer USERS>

This option let's you invite a list of users to review your change.

USERS is a colon-separated list of usernames. You may also pass this
option more than once, to invite more than a set of users.

=item B<--cc USERS>

This option let's you notify a list of users about your change.

USERS is a colon-separated list of usernames. You may also pass this
option more than once, to invite more than a set of users.

=back

=head2 git gerrit query [--limit LIMIT] [--verbose] [[NAME=]QUERY]*

The B<query> sub-command let's you list Gerrit changes meeting
specific criterea. The matching changes are shown in tabular format,
one change per line, listing their legacy ID, status, time of last
update, project name, branch name, owner name, and subject line.

You may pass a list of queries. Each QUERY's results is presented
separated from the other by a empty line and a header containing the
query's name and expression inside brackets. For example:

    $ git gerrit query 'Starred changes=is:starred' is:draft

    [Starred changes=is:starred]
    ID    STATUS UPDATED    PROJECT    BRANCH OWNER          SUBJECT
    1186  MERGED 2013-09-18 helloworld master Gustavo Chaves [SB-1] Test amend 3

    [QUERY=is:draft]
    ID    STATUS UPDATED    PROJECT    BRANCH OWNER          SUBJECT
    1187  NEW    2013-09-08 helloworld master Gustavo Chaves [SB-2] Make foo

Note that unamed queries are prefixed by C<QUERY=> instead of by their names.

Each QUERY can be specified by a L<Gerrit search
expression|https://gerrit-review.googlesource.com/Documentation/user-search.html>.

=over

=item B<--limit LIMIT>

This option put a limit on the number of changes that are shown for
each QUERY.

=item B<--verbose>

This option makes the change topic be shown inside parenthesis to the
right of the change branch name. This requires a separate REST call
for each change, making the result appear more slowly.

=back

=head2 git gerrit my [--limit LIMIT] [--verbose] [changes|drafts|watched|starred]

The B<my> sub-command provides a set of pre-defined queries for the
B<query> sub-command. It's based on Gerrit's standard queries shown in
its web interface under the C<My> tab.

The C<changes> argument is used by default if you don't specify any.

The options taken by the C<my> sub-command are passed to the C<query>
sub-command.

=head2 git gerrit show [--verbose] [CHANGE]

The B<show> sub-command describes a CHANGE in detail, showing much
like what Gerrit shows in a change page of its web interface. For
example:

    $ git gerrit show 1186
     Change-Num: 1186
      Change-Id: I0bb976fe1890657d7a1c3ba403e0b58ac2b63cd7
        Subject: [SB-1] Test amend 3
          Owner: Gustavo Chaves
        Project: helloworld
         Branch: master
        Created: 2013-09-18 16:22:21.000000000
        Updated: 2013-09-18 19:45:56.000000000
         Status: MERGED

If a CHANGE is not passed the branch associated with the current
change-branch is described. If you're not in a change-branch, you'll
get an error.

=over

=item B<--verbose>

This option makes the change topic, if any, be shown too. This
requires a separate REST call, making the result a bit slower.

=back

=head2 git gerrit checkout [CHANGE]

The B<checkout> sub-command fetches a CHANGE from Gerrit, creates a
change-branch pointing to it and checks it out, leaving your working
area in the CHANGE state.

A Gerrit change may contain a series of patchsets. The C<checkout>
fetches the current (latest) one. If there is already a change-branch
for the change, it will be updated to the change's current patchset.

If you omit the CHANGE argument and you are in a change-branch, it wil
be updated with its current patchset.

=head2 git gerrit backout [--keep]

The B<backout> sub-command should be invoked when you're in a
change-branch. It checks out the upstream branch and deletes the
change-branch.

=over

=item B<--keep>

This option avoids the change-branch deletion.

=back

=head2 git gerrit reviewer [--add USERS] [--confirm] [--delete USERS] [CHANGE]

The B<reviewer> sub-command allows you to manage the list of reviewers
for a CHANGE. You can omit the CHANGE argument if you're in a
change-branch. In this case, you'll be managing the associated change
reviewers.

=over

=item B<--add USERS>

This option let's you invite new users to review the change. You can
pass a comma-separated list of users and even use more than one
C<--add> option.

You can use Gerrit groupnames in addition to usernames, if you want to
invite a group of users to review.

=item B<--confirm>

Gerrit may reject the addition of groups with too many users because
it recons you may be doing it by mistake. In this case, you'll receive
an error message something like this:

    "The group My Group has 15 members. Do you want to add them all as reviewers?"

If you really want to invite them all, try again with using the
C<--confirm> option.

=item B<--delete USERS>

This option let's you remove reviewers from the change. You can pass a
comma-separated list of users and even use more than one C<--delete>
option.

You can use Gerrit groupnames in addition to usernames, if you want to
remove a group of reviewers.

=back

After adding and removing reviewers, C<git gerrit reviewers> shows the
remaining list of reviewers of the CHANGE.

=head2 git gerrit review [--message TEXT] [--keep] [[LABEL]=VOTE]* [CHANGE]

The B<review> sub-command allows you to review (duh!) a CHANGE by
casting votes and adding messages to it.

You can omit the CHANGE argument if you are in a change-branch, in
which case you'll be reviewing the associated change. In this case,
after a successful review, the change-branch will be deleted and its
upstream checked out.

You can cast multiple votes using C<LABEL=VOTE> arguments, where LABEL
names a Gerrit
L<label|https://gerrit-review.googlesource.com/Documentation/config-labels.html>
and VOTE is a negative, zero, or positive number. If you omit the
LABEL name (but not the equal sign!) you'll be voting in the standard
C<Code-Review> label.

The Git editor (see the definintion of C<GIT_EDITOR> with the C<git
help var> command) is invoked for you to compose a message to be added
to the review.

=over

=item B<--message TEXT>

This option adds a message to the review avoinding the Git editor
invocation.

=item B<--keep>

This option avoids the change-branch deletion after a successful review.

=back

=head2 git gerrit submit [--no-wait-for-merge] [--keep] [CHANGE]

The B<submit> sub-command submits an approved CHANGE, making Gerrit
merge it into its remote upstream branch.

You can omit the CHANGE argument if you are in a change-branch, in
which case you'll be submitting the associated change. In this case,
after a successful submition, the change-branch will be deleted and
its upstream checked out.

=over

=item B<--no-wait-for-merge>

By default git-gerrit will wait for the merge of the change into its
branch to complete in Gerrit. This option tells it not to wait and
finish as soon as it receives Gerrit's submit acknowledge.

=item B<--keep>

This option avoids the change-branch deletion after a successful
submition.

=back

=head2 git gerrit abandon [--message TEXT] [--keep] [CHANGE]

The B<abandon> sub-command abandons an unmerged CHANGE.

You can omit the CHANGE argument if you are in a change-branch, in
which case you'll be abandoning the associated change. In this case,
after a successful abandonment, the change-branch will be deleted and
its upstream checked out.

The Git editor (see the definintion of C<GIT_EDITOR> with the C<git
help var> command) is invoked for you to compose a message to be added
to the action.

=over

=item B<--message TEXT>

This option adds a message to the review avoinding the Git editor
invocation.

=back

=over

=item B<--keep>

This option avoids the change-branch deletion after a successful
abandonment.

=back

=head2 git gerrit restore [--message TEXT] [CHANGE]

The B<restore> sub-command restores an abandoned CHANGE.

You can omit the CHANGE argument if you are in a change-branch, in
which case you'll be restoring the associated change.

The Git editor (see the definintion of C<GIT_EDITOR> with the C<git
help var> command) is invoked for you to compose a message to be added
to the action.

=over

=item B<--message TEXT>

This option adds a message to the review avoinding the Git editor
invocation.

=back

=head2 git gerrit revert [--message TEXT] [CHANGE]

The B<revert> sub-command reverts an already merged CHANGE. Gerrit
does so by creating, in the server, a new change with an inverted
patch on top of the CHANGE remote upstream branch.

You can omit the CHANGE argument if you are in a change-branch, in
which case you'll be reverting the associated change.

The Git editor (see the definintion of C<GIT_EDITOR> with the C<git
help var> command) is invoked for you to compose a message to be added
to the action.

=over

=item B<--message TEXT>

This option adds a message to the review avoinding the Git editor
invocation.

=back

=head2 git gerrit config

The B<config> sub-command lists Git's configuration variables in the
C<git-gerrit> section. It's just a shortcut to

    git config --get-regexp "^git-gerrit\."

=head2 git gerrit version

The B<version> sub-command shows the versions of git-gerrit, Git, and
Gerrit that you're using.

=head1 COMMIT-MSG HOOK

Gerrit provides a C<commit-msg> hook for Git that should be installed
in your repositories. The purpose of it is to insert a C<Change-Id>
footer in the commit messages so that Gerrit can discern independent
commits from merelly amended ones.

Git-gerrit takes care of installing this hook for you. When you invoke
its C<new> or C<push> sub-commands, it checks to see if your
repository already has a C<commit-msg> hook installed. If not, it
automatically downloads Gerrit's standard hook and installs it for
you.

=head1 GERRIT WORKFLOW

Here are the main use-cases of git-gerrit to manage your changes.

=head2 Creating a new change for review

Suppose you want to create a new change on master:

    git gerrit new topic master
    # edit
    git commit
    git gerrit push

First you create a new change-branch for your new change. If you're
already in master you don't need to mention it on the first line. Then
you make your change editing your working area and commiting. When
you're done, simply tell git-gerrit to push your change and get back
to master.

In order to do the same thing using only standard Git commands you'd
do something like this:

    git checkout master
    git pull --ff-only
    git checkout -b topic
    # edit
    git commit
    git push origin HEAD:refs/for/master
    git checkout master
    git branch -D topic

=head2 Reviewing a change

    git gerrit my changes
    git gerrit checkout 1234
    git show
    git gerrit review =-1

First, if you don't know the C<{change-id}> of the change you want to
review, you ask C<my changes> to get a list of the changes still
unreviewed. Then you checkout one change and study it. Finally, you
record your review and gets back to the change's upstream branch.

Without git-gerrit you'd have to perform the review using Gerrit's web
interface.

=head2 Amendind a change

    git gerrit checkout 1234
    # edit
    git commit --amend
    git gerrit push

To amend a change you first check it out to a local
change-branch. Then you can amend it and, finally, push it as another
patchset to Gerrit, checking out upstream again.

Without git-gerrit you would have to go first to Gerrit's web
interface, find the change, and copy its fetch/checkout command
line. Then you could paste it in your terminal and perform the
amending like this:

    git fetch https://gustavo@gerrit.example.net/project refs/changes/90/1190/2 && git checkout FETCH_HEAD
    # edit
    git commit --amend
    git push origin HEAD:refs/for/master
    git checkout master

=head1 SEE ALSO

There are some alternatives to git-gerrit, other Git extensions to
make it easier to interact with Gerrit. The three mentioned below are
the most well known. All of them use Gerrit's mature and simple SSH
API while git-gerrit's distinguishes from them in that it uses
Gerrit's newer and more comprehensive REST API.

=over

=item * L<git-review|https://github.com/openstack-infra/git-review>

Being the original inspiration for git-gerrit, git-review is a mature
tool that's used by some very well known projects, such as OpenStack,
MediaWiki, and LibreOffice.

=item * L<git-change|https://github.com/Nextdoor/git-change>

Simpler than git-review, git-change is better documented and has the
best name of all. From it, git-gerrit took the change-branch concept.

=item * L<querrit|https://gitorious.org/querrit/querrit>

A very simple tool to query Gerrit and make it easier to push changes.

=back

=head1 PREREQUISITES

=over

=item * C<Data::Dumper>

=item * C<File::Spec>

=item * C<File::Slurp>

=item * C<File::Temp>

=item * C<Gerrit::REST>

=item * C<Getopt::Long>

=item * C<Pod::Usage>

=item * C<URI::Escape>

=item * C<URI>

=back

=head1 COREQUISITES

=over

=item * C<LWP::Simple>

=back

=pod OSNAMES

any

=pod SCRIPT CATEGORIES

VersionControl/Git
VersionControl/Gerrit

=head1 COPYRIGHT

Copyright 2013 CPqD.

This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=head1 AUTHOR

Gustavo Chaves <gnustavo@cpan.org>
