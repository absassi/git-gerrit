#!/usr/bin/env perl

use 5.010;
use utf8;
use strict;
use warnings;
use autodie;
use Pod::Usage;
use Getopt::Long qw(:config auto_version auto_help);
use URI;
use URI::Escape;
use lib '/home/gustavo/git/mine/gerrit-rest/lib';
use Gerrit::REST;

# The %Options hash is used to hold the command line options passed to
# all git-gerrit subcommands. The --verbose option is common to all of
# them. Each subcommand supports a specific set of options which are
# grokked by the get_options routine below.

my %Options = ( verbose => 0 );
sub get_options {
    my ($optref, @opt_specs) = @_;
    return GetOptions(\%Options, 'verbose+', @opt_specs)
        or pod2usage(2);
}

# The cmd routine is used to invoke shell commands, usually git. It
# prints out the command before invoking it in verbose operation.

sub cmd {
    my ($cmd) = @_;
    warn "CMD: $cmd\n" if $Options{verbose};
    return system($cmd) == 0;
}

# The %Config hash holds the git-gerrit section configuration options.

my %Config;
sub grok_config {
    warn "CMD: git config --get-regexp \"^git-gerrit\\.\"\n"
        if $Options{verbose};
    {
        open my $pipe, '-|', 'git config --get-regexp "^git-gerrit\."';
        while (<$pipe>) {
            if (/^git-gerrit\.(\S+)\s+(.*)/) {
                $Config{$1} = $2;
            } else {
                warn "Strange git-config output: $_";
            }
        }
    }

    # Override option defaults
    for my $opt (qw/verbose/) {
        $Options{$opt} = $Config{"default-$opt"}
            if exists $Config{"default-$opt"};
    }

    state $remotes //= do {
        my %remotes;
        open my $pipe, '-|', join(' ', "git remote -v show -n", @_)
            or die "ERROR: can't fork git-remote: $!\n";
        while (<$pipe>) {
            # save only remotes using http/https
            if (/(?<name>\S+)\s+(?<url>http\S+)/i) {
                $remotes{$+{name}} = $+{url};
            }
        }
        close $pipe
            or die "You have to be inside a git repository to use git-gerrit.\n";
        \%remotes;
    };

    unless ($Config{remote}) {
        # We require Term::Prompt to ask the user interactivelly for
        # the remote. If we can't, we die with a helpful message.
        eval { require Term::Prompt };
        if ($@) {
            die <<EOF;

Please, set up the git-gerrit.remote variable with the name of the git
remote referring to your Gerrit server. Note that it must use an
HTTP(S) URL. You may set it like this

    git config git-gerrit.remote <remote>

(If you had the Term::Prompt Perl module installed I could ask you the
remote's name and set it up for you.)

EOF
        }

        my @remotes = sort keys %$remotes;
        my @items   = map {"$_ ($remotes->{$_})"} @remotes;
        push @items, 'None of the above!';
        my $item = Term::Prompt::prompt(
            'm',
            {
                prompt => 'prompt',
                title  => "\nPlease, tell me which remote refers to your Gerrit server:",
                items  => \@items,
                accept_empty_selection => 0,
            },
        );
        if ($item < @remotes) {
            my $remote = $remotes[$item];
            cmd "git config git-gerrit.remote $remote";
            $Config{remote} = $remote;
            $Config{url} = $remotes->{$remote};
        } else {
            die <<EOF;

To use git-gerrit you have to set a git remote referring to your
Gerrit server via a HTTP(S) URL. Please, set one using the following
command and try again:

    git remote add <name> <url>

EOF
        }
    }

    unless ($Config{url}) {
        my $url = $remotes->{$Config{remote}}
            or die <<EOF;

Your git-gerrit.remote variable is set to '$Config{remote}', but there
is no remote by that name configured with a HTTP(S) URL. Please, fix
that configuration variable and try again.

EOF
        $Config{url} = $url;
    }

    $Config{url} = URI->new($Config{url});

    # The url's path is the project
    $Config{project} = substr($Config{url}->path, 1); # the path but the leading slash
    $Config{url}->path('');     # trim off the path

    return;
}

sub credential_description {
    my $url = $Config{url};

    my $protocol = $url->scheme;
    my $host     = $url->host;
    my $path     = $url->path;

    my $site_description = <<EOF;
protocol=$protocol
host=$host
path=$path
EOF

    my $username = $url->userinfo;
    my $user_description = do {
        if (defined $username) {
            $username =~ s/:.*//;   # trim off the password, if any
            "username=$username\n";
        } else {
            undef;
        }
    };

    return ($site_description, $user_description);
}

sub get_credentials {
    my ($site, $user) = credential_description();

    # Create a temporary file to hold the credential description
    require File::Temp;
    my ($fh, $credfile) = File::Temp::tempfile(UNLINK => 1);
    $fh->print($site);
    $fh->print($user) if $user;
    $fh->print("\n");
    $fh->close;

    my %credentials;
    open my $pipe, '-|', "git credential fill <$credfile";
    while (<$pipe>) {
        chomp;
        $credentials{$1} = $2 if /^([^=]+)=(.*)/;
    }
    close $pipe;

    for my $key (qw/username password/) {
        exists $credentials{$key} or die "Couldn't get credential's $key\n";
    }

    return @credentials{qw/username password/};
}

sub set_credentials {
    my ($username, $password, $what) = @_;

    $what =~ /^(?:approve|reject)$/
        or die "set_credentials \$what argument ($what) must be either 'approve' or 'reject'\n";

    my ($site) = credential_description();

    open my $git, '|-', "git credential $what";
    $git->print($site, "username=$username\n\n");
    $git->close;

    return;
}

sub gerrit {
    my $method = shift;

    state $gerrit;
    unless ($gerrit) {
        my ($username, $password) = get_credentials;
        $gerrit = Gerrit::REST->new($Config{url}->as_string, $username, $password);
        eval { $gerrit->GET("/projects/" . uri_escape_utf8($Config{project})) };
        if ($@) {
            set_credentials($username, $password, 'reject');
            die $@;
        } else {
            set_credentials($username, $password, 'approve');
        }
    }

    warn join(' ', 'Gerrit:', $method, @_), "\n" if $Options{verbose};

    return $gerrit->$method(@_);
}

sub query_changes {
    # If no query is specified we use the standard query for Gerrit's
    # "My Changes" dashboard.
    my @queries = @_ ? @_ : qw/is:open+owner:self is:open+reviewer:self+-owner:self/;

    # If we're inside a git repository, restrict the query to the
    # current project's reviews.
    if (my $project = $Config{project}) {
        $project = uri_escape_utf8($project);
        @queries = map "q=project:$project+$_", @queries;
    }

    push @queries, "n=$Options{limit}" if $Options{limit};

    push @queries, "o=DETAILED_ACCOUNTS";

    my $changes = gerrit(GET => "/changes/?" . join('&', @queries));
    $changes = [$changes] if ref $changes->[0] eq 'HASH';

    return $changes;
}

sub get_change {
    my ($id, $allrevs) = @_;

    my $revs = $allrevs ? 'ALL_REVISIONS' : 'CURRENT_REVISION';
    return (gerrit(GET => "/changes/?q=change:$id&o=$revs"))[0][0];
}

sub change_refspecs {
    my ($change) = @_;

    my %refspecs;
    foreach my $patch (sort {$a->{_number} <=> $b->{_number}} values %{$change->{revisions}}) {
        my $http = $patch->{fetch}{http};
        push @{$refspecs{$http->{url}}}, "$http->{ref}:review/$change->{_number}/$patch->{_number}";
    }
    return \%refspecs;
}

sub current_branch {
    chomp(my $branch = qx/git rev-parse --abbrev-ref HEAD/);
    return $branch;
}

sub update_branch {
    my ($branch) = @_;

    cmd "git fetch $Config{remote} $branch:$branch";
}

############################################################
# SUBCOMMANDS

my %commands;

$commands{new} = sub {
    get_options('update');

    my ($topic, $branch) = @_;

    defined $topic or pod2usage("new: Missing TOPIC");

    $branch = current_branch();

    $branch !~ m:^change/: or pod2usage "new: Missing BRANCH\n";

    qx/git status --porcelain --untracked-files=no/ eq "\n"
        or die "new: Can't create new change because git-status is dirty\n";

    if ($Options{update}) {
        update_branch($branch)
            or die "new: Non-fast-forward pull. Please, merge or rebase your branch first.\n";
    }

    cmd "git checkout -b change/$branch/$topic";
};

$commands{query} = sub {
    get_options('limit=i');

    my $changes = query_changes(@_);

    # FIXME: consider using Text::Table for formatting
    my $format = "%-5s %-9s %-19s %-12s %-12s %-24s %s\n";
    for (my $i=0; $i < @$changes; ++$i) {
        print "[[$_[$i]]]\n";
        next unless @{$changes->[$i]};
        printf $format, 'ID', 'STATUS', 'UPDATED', 'PROJECT', 'BRANCH', 'OWNER', 'SUBJECT';
        foreach my $change (sort {$b->{updated} cmp $a->{updated}} @{$changes->[$i]}) {
            if ($Options{verbose}) {
                if (my $topic = gerrit(GET => "/changes/$change->{id}/topic")) {
                    $change->{branch} .= " ($topic)";
                }
            }
            printf $format,
                   $change->{_number},
                   $change->{status},
                   substr($change->{updated}, 0, 19),
                   $change->{project},
                   $change->{branch},
                   substr($change->{owner}{name}, 0, 24),
                   $change->{subject};
        }
    }
};

$commands{show} = sub {
    my $id = shift
        or pod2usage "show: Missing CHANGE.\n";

    my $change = gerrit(GET => "/changes/$id/detail");

    print <<EOF;
Change-Num: $change->{_number}
Change-Id:  $change->{change_id}
Subject:    $change->{subject}
Owner:      $change->{owner}{name}
EOF

    if ($Options{verbose}) {
        if (my $topic = gerrit(GET => "/changes/$id/topic")) {
            $change->{topic} = $topic;
        }
    }

    for my $key (qw/project branch topic created updated status reviewed mergeable/) {
        printf "%-12s %s\n", "\u$key:", $change->{$key}
            if exists $change->{$key};
    }

    for my $label (sort keys %{$change->{permited_labels}}) {
        for my $review (sort {$a->{name} cmp $b->{name}} @{$change->{labels}{$label}{all}}) {
            printf "%-12s %-32s %+2d\n", "$label:", @{$review}{qw/name value/};
        }
    }
};

$commands{checkout} = sub {
    my ($id) = shift or pod2usage("You have to specify a CHANGE");

    my $change = get_change($id);

    my ($revision) = values %{$change->{revisions}};

    my ($url, $ref) = @{$revision->{fetch}{http}}{qw/url ref/};

    my $branch = "change/$change->{branch}/$change->{_number}";

    cmd "git fetch $url $ref:$branch"
        or die "Can't fetch $url\n";

    cmd "git checkout $branch";
};

$commands{push} = sub {
    get_options(
        'keep',
        'rebase',
        'update',
        'topic=s',
        'reviewer=s@',
        'cc=s@'
    );

    qx/git status --porcelain --untracked-files=no/ eq "\n"
        or die "push: Can't push change because git-status is dirty\n";

    my $change_branch = current_branch();

    my ($prefix, $branch, $topic, $id) = split m:/:, $change_branch;

    $prefix eq 'change' or die "push: You must be in a change branch to push it\n";

    if ($Options{update}) {
        update_branch($branch)
            or die "push: Non-fast-forward pull. Please, merge or rebase your branch first.\n";
    }

    if ($Options{rebase}) {
        cmd "git rebase $branch";
    }

    my $refspec = "HEAD:refs/for/$branch";

    my @tags;
    if (my $topic = $Options{topic}) {
        push @tags, "topic=$topic";
    }
    if (my $reviewers = $Options{reviewer}) {
        push @tags, map("r=$_", split(/,/, join(',', @$reviewers)));
    }
    if (my $ccs = $Options{cc}) {
        push @tags, map("cc=$_", split(/,/, join(',', @$ccs)));
    }
    if (@tags) {
        $refspec .= '%';
        $refspec .= join(',', @tags);
    }

    cmd "git push $Config{remote} $refspec"
        or die "push: Error pushing change.\n";

    return if $Options{keep};

    cmd "git checkout $branch";

    cmd "git branch -D $change_branch";
};

$commands{reviewer} = sub {
    get_options(
        'add=s@',
        'confirm',
        'delete=s@',
    );

    my $change = shift
        or pod2usage "reviewer: Missing CHANGE.\n";

    # First try to make all deletions
    if (my $users = $Options{delete}) {
        foreach my $user (split(/,/, join(',', @$users))) {
            gerrit(DELETE => "/changes/$change/reviewers/$user");
        }
    }

    # Second try to make all additions
    if (my $users = $Options{add}) {
        my $confirm = $Options{confirm} ? 'true' : 'false';
        foreach my $user (split(/,/, join(',', @$users))) {
            gerrit(POST => "/changes/$change/reviewers/$user", { reviewer => $user, confirm => $confirm});
        }
    }

    # Finally, list current reviewers
    my @reviewers = gerrit(GET => "/changes/$change/reviewers");
    print "There are ", scalar(@reviewers), " reviewers currently:\n";
    foreach my $reviewer (@reviewers) {
        print "$reviewer->{name}\t$reviewer->{email}\t";
        foreach my $approval (sort keys $reviewer->{approvals}) {
            print "$approval:$reviewer->{approvals}{$approval}";
        } continue {
            print ", ";
        }
        print "\n";
    }
};

$commands{review} = sub {
    get_options('message=s');

    my $vote = shift
        or pod2usage "review: Missing VOTE.\n";
    $vote =~ /^[+-]?[012]$/
        or pod2usage "review: Invalid vote ($vote). It must be from -2 to +2.\n";

    my $change = shift
        or pod2usage "review: Missing CHANGE.\n";

    my %review = ( labels => { 'Code-Review' => $vote } );
    $review{message} = $Options{message} if $Options{message};

    gerrit(POST => "/changes/$change/revisions/current/review", \%review);
};

$commands{abandon} = sub {
    get_options('message=s');

    my ($change) = @_;

    my @args = ("/changes/$change/abandon");
    push @args, { message => $Options{message} } if $Options{message};
    gerrit(POST => @args);
};

$commands{restore} = sub {
    get_options('message=s');

    my ($change) = @_;

    my @args = ("/changes/$change/restore");
    push @args, { message => $Options{message} } if $Options{message};
    gerrit(POST => @args);
};

$commands{revert} = sub {
    get_options('message=s');

    my ($change) = @_;

    my @args = ("/changes/$change/revert");
    push @args, { message => $Options{message} } if $Options{message};
    gerrit(POST => @args);
};

$commands{submit} = sub {
    get_options('wait-for-merge');

    my ($change) = @_;

    my @args = ("/changes/$change/submit");
    push @args, { wait_for_merge => 1 } if $Options{'wait-for-merge'};
    gerrit(POST => @args);
};

# MAIN

my $command = shift
    or die pod2usage("Missing command name");

exists $commands{$command}
    or die pod2usage("Invalid command: $command");

grok_config;

$commands{$command}->(@ARGV);

__END__
=head1 NAME

git-gerrit - Git extension to implement a Gerrit workflow

=head1 SYNOPSIS

    git gerrit new        [--update] TOPIC [BRANCH]
    git gerrit query      [--limit LIMIT] [--verbose] QUERY*
    git gerrit show       CHANGE
    git gerrit checkout   CHANGE
    git gerrit push       [--keep] [--rebase] [--update] [--reviewer USER] [--cc USER]
    git gerrit reviewer   [--add USER|GROUP] [--confirm] [--delete USER|GROUP] CHANGE
    git gerrit review     [--message TEXT] {-2..+2} CHANGE
    git gerrit abandon    [--message TEXT] CHANGE
    git gerrit restore    [--message TEXT] CHANGE
    git gerrit revert     [--message TEXT] CHANGE
    git gerrit submit     [--wait-for-merge] CHANGE

    git gerrit log
    git gerrit cherrypick [--no-commit] [--indicate] CHANGE
    git gerrit diff       CHANGE-RANGE

=head1 OPTIONS

=over

=item

=back

=head1 DESCRIPTION

=head1 SEE ALSO

=over

=item * L<git-review|https://github.com/openstack-infra/git-review>:
Another script implementing a Gerrit workflow in Git.

=back

=head1 PREREQUISITES

=over
=item * C<Pod::Usage>
=item * C<Getopt::Long>
=item * C<File::Temp>
=item * C<Gerrit::REST>
=item * C<URI>
=item * C<URI::Escape>
=back

=head1 COREQUISITES

=over
=item * C<Term::Prompt>
=back

=pod OSNAMES

any

=pod SCRIPT CATEGORIES

VersionControl/Git
VersionControl/Gerrit

=head1 COPYRIGHT

Copyright 2013 CPqD.

This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=head1 AUTHOR

Gustavo Chaves <gnustavo@cpan.org>
